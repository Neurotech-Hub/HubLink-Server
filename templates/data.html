{% extends "base.html" %}

{% block title %}Data{% endblock title %}

{% block content %}
<div class="container-fluid py-4">
    <h2 class="mb-4">Data</h2>

    <div id="dataContent" 
         hx-get="{{ url_for('accounts.account_data_content', account_url=account.url) }}"
         hx-trigger="load, every 30s"
         hx-swap="innerHTML transition:true">
        <div class="fade-me">
            <div class="text-center py-5">
                <div class="spinner-border" role="status">
                    <span class="visually-hidden">Loading data...</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- File Details Modal -->
<div class="modal fade" id="fileDetailsModal" tabindex="-1" aria-labelledby="fileDetailsModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="fileDetailsModalLabel">File Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <table class="table table-sm">
                    <tbody>
                        <tr>
                            <th>Filename:</th>
                            <td id="modalFilename"></td>
                        </tr>
                        <tr>
                            <th>Size:</th>
                            <td id="modalSize"></td>
                        </tr>
                        <tr>
                            <th>Last Modified:</th>
                            <td id="modalLastModified"></td>
                        </tr>
                        <tr>
                            <th>Version:</th>
                            <td id="modalVersion"></td>
                        </tr>
                        <tr>
                            <th>Last Checked:</th>
                            <td id="modalLastChecked"></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- JavaScript for file operations -->
<script>
function showFileDetails(fileId, key, size, lastModified, version, lastChecked) {
    document.getElementById('modalFilename').textContent = key;
    document.getElementById('modalSize').textContent = size;
    document.getElementById('modalLastModified').textContent = lastModified ? new Date(lastModified).toLocaleString() : 'Never';
    document.getElementById('modalVersion').textContent = version || 'N/A';
    document.getElementById('modalLastChecked').textContent = lastChecked ? new Date(lastChecked).toLocaleString() : 'Never';
    
    new bootstrap.Modal(document.getElementById('fileDetailsModal')).show();
}

function downloadAllFiles(directory) {
    window.location.href = `/download?directory=${encodeURIComponent(directory)}`;
}

// Initialize event listeners after HTMX content swap
document.body.addEventListener('htmx:afterSwap', function(evt) {
    if (evt.detail.target.id === 'dataContent') {
        initializeEventListeners();
    }
});

function initializeEventListeners() {
    let selectedFiles = new Set();
    let totalSize = 0;
    
    // Update selection counters
    function updateSelectionCounters() {
        document.getElementById('selectedCount').textContent = selectedFiles.size;
        document.getElementById('selectedSize').textContent = formatBytes(totalSize);
        
        // Enable/disable buttons based on selection
        const hasSelection = selectedFiles.size > 0;
        document.getElementById('clearSelectionBtn').disabled = !hasSelection;
        document.getElementById('downloadSelectedBtn').disabled = !hasSelection;
        if (document.getElementById('deleteSelectedBtn')) {
            document.getElementById('deleteSelectedBtn').disabled = !hasSelection;
        }
    }
    
    // Handle checkbox changes
    document.addEventListener('change', function(e) {
        if (e.target.matches('.file-select')) {
            const fileId = parseInt(e.target.dataset.id);
            const fileSize = parseInt(e.target.dataset.size);
            
            if (e.target.checked) {
                selectedFiles.add(fileId);
                totalSize += fileSize;
            } else {
                selectedFiles.delete(fileId);
                totalSize -= fileSize;
            }
            
            updateSelectionCounters();
        }
    });
    
    // Clear selection button
    const clearBtn = document.getElementById('clearSelectionBtn');
    if (clearBtn) {
        clearBtn.addEventListener('click', function() {
            document.querySelectorAll('.file-select:checked').forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedFiles.clear();
            totalSize = 0;
            updateSelectionCounters();
        });
    }
    
    // Download selected files
    const downloadBtn = document.getElementById('downloadSelectedBtn');
    if (downloadBtn) {
        downloadBtn.addEventListener('click', function() {
            if (selectedFiles.size > 0) {
                const fileIds = Array.from(selectedFiles);
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                const downloadData = { file_ids: fileIds };
                
                fetch('/{{ account.url }}/download_files', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(downloadData)
                })
                .then(response => {
                    if (response.ok) {
                        return response.blob();
                    }
                    throw new Error('Network response was not ok.');
                })
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hublink_${timestamp}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    a.remove();
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error downloading files');
                });
            }
        });
    }
    
    // Delete selected files (admin only)
    const deleteBtn = document.getElementById('deleteSelectedBtn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', function() {
            if (selectedFiles.size > 0 && confirm('Are you sure you want to delete the selected files?')) {
                const fileIds = Array.from(selectedFiles);
                const currentDirectory = document.getElementById('directorySelect')?.value;
                const deleteData = {
                    file_ids: fileIds,
                    directory: currentDirectory
                };
                
                fetch('/{{ account.url }}/files/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(deleteData)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.redirect) {
                        window.location.href = data.redirect;
                    } else {
                        // Refresh the content
                        document.getElementById('dataContent').dispatchEvent(
                            new Event('htmx:afterSettle', { bubbles: true })
                        );
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error deleting files');
                });
            }
        });
    }
}

// Helper function to format bytes
function formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Initialize event listeners on page load
document.addEventListener('DOMContentLoaded', initializeEventListeners);
</script>
{% endblock content %}